import { platform } from 'node:os';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import isEmpty from '@roots/bud-support/lodash/isEmpty';
import isString from '@roots/bud-support/lodash/isString';
import { open, openEditor } from '@roots/bud-support/open';
const notifierPath = resolve(dirname(fileURLToPath(import.meta.url)), `..`, // bud-framework
`vendor`, `mac.no-index`, `roots-notifier.app`, `Contents`, `MacOS`, `roots-notifier`);
/**
 * Notifier
 */
export class Notifier {
    _app;
    /**
     * Browser to open on error
     */
    browser;
    /**
     * Track if browser has already been opened once
     * to prevent multiple browser tabs from opening
     * when changes are saved.
     *
     * When {@link Notifier.openBrowser} is called and this
     * prop is true the call exits early. Otherwise, the
     * browser is opened and this prop is set to true.
     *
     * @see {@link https://github.com/roots/bud/issues/2041}
     */
    browserOpened = false;
    /**
     * Editor to open on error
     */
    editor;
    /**
     * Node-notifier notification center instance
     */
    notificationCenter;
    constructor(_app) {
        this._app = _app;
        this.make = this.make.bind(this);
        this.notify = this.notify.bind(this);
        this.openBrowser = this.openBrowser.bind(this);
        this.openEditor = this.openEditor.bind(this);
    }
    /**
     * Get bud instance
     */
    get app() {
        return this._app();
    }
    /**
     * Make notifier
     */
    async make(bud) {
        if (this.notificationsEnabled) {
            const { NotificationCenter } = await import(`@roots/bud-support/node-notifier`);
            this.notificationCenter =
                platform() !== `darwin`
                    ? new NotificationCenter()
                    : new NotificationCenter({ customPath: notifierPath });
        }
        if (bud.env.has(`BUD_EDITOR`)) {
            this.editor = bud.env.get(`BUD_EDITOR`);
        }
        else if (bud.env.has(`VISUAL`)) {
            this.editor = bud.env.get(`VISUAL`);
        }
        else if (bud.env.has(`EDITOR`)) {
            this.editor = bud.env.get(`EDITOR`);
        }
    }
    /**
     * True if notifications are enabled
     */
    get notificationsEnabled() {
        return this.app?.context.notify === true;
    }
    /**
     * Emit OS notification center notice
     */
    notify(notification, callback) {
        if (!this.notificationsEnabled)
            return;
        this.notificationCenter.notify({
            group: this.app.label,
            title: this.app.label,
            ...notification,
        }, callback);
    }
    /**
     * Open browser in development
     */
    async openBrowser(url) {
        if (!this.app.isDevelopment)
            return;
        if (!this.openBrowserEnabled)
            return;
        if (!isString(url))
            return;
        if (this.browserOpened)
            return;
        this.browserOpened = true;
        if (isString(this.browser)) {
            return await open(url, { app: { name: this.browser } });
        }
        return await open(url);
    }
    /**
     * True if browser opening is enabled
     */
    get openBrowserEnabled() {
        return this.app?.context.browser === true;
    }
    /**
     * Open editor on error
     */
    openEditor(input) {
        if (!this.openEditorEnabled)
            return;
        if (!isString(this.editor))
            return;
        if (!input || isEmpty(input))
            return;
        const files = Array.isArray(input) ? input : [input];
        files.map(file => this.app.info(`opening`, file, `in`, this.editor));
        return openEditor(files, { editor: this.editor });
    }
    /**
     * True if editor opening is enabled
     */
    get openEditorEnabled() {
        return this.app?.context.editor === true;
    }
}
