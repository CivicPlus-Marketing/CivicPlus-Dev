import { __decorate, __metadata } from "tslib";
import { jsxs as _jsxs, jsx as _jsx } from "react/jsx-runtime";
import { Command, Option } from '@roots/bud-support/clipanion';
import { bind } from '@roots/bud-support/decorators/bind';
import { Box, Text } from '@roots/bud-support/ink';
import BudCommand from '@roots/bud/cli/commands/bud';
import { dry } from '@roots/bud/cli/decorators/dry';
import storage from '@roots/bud/cli/flags/storage';
/**
 * `bud clean`
 */
let BudCleanCommand = class BudCleanCommand extends BudCommand {
    static paths = [[`clean`]];
    static usage = Command.Usage({
        category: `tasks`,
        description: `Clean project artifacts and caches`,
        details: `
      \`bud clean\` empties the \`@dist\` and \`@storage\` directories.
      \`bud clean @dist\` empties the \`@dist\` directory.
      \`bud clean @storage\` empties the \`@storage\` directory.
      \`bud clean cache\` empties the \`@storage/cache\` directory.
`,
        examples: [
            [`Clean artifacts/caches`, `$0 clean`],
            [`Clean dist`, `$0 clean @dist`],
            [`Clean storage`, `$0 clean @storage`],
        ],
    });
    cachePositional = Option.Boolean(`@cache,cache`, false, {
        description: `empty @cache`,
    });
    outputPositional = Option.Boolean(`@dist,dist,output`, false, {
        description: `empty @dist`,
    });
    storage = storage;
    storagePositional = Option.Boolean(`@storage,storage`, false, {
        description: `empty @storage`,
    });
    async cleanCache() {
        if (this.bud.hasChildren) {
            return await Promise.all(Object.values(this.bud.children)
                .filter(this.filterCompiler)
                .map(async (child) => {
                await this.bud.fs.remove(child.cache.cacheDirectory);
                await this.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", child.cache.cacheDirectory] }) }));
            }));
        }
        await this.bud.fs.remove(this.bud.path(`@os-cache`));
        await this.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", this.bud.cache.cacheDirectory] }) }));
        await this.bud.fs.remove(this.bud.path(`@storage`, `conf`));
        await this.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", this.bud.path(`@storage`, `conf`)] }) }));
    }
    async cleanOutput() {
        if (this.bud.hasChildren) {
            return await Promise.all(Object.values(this.bud.children)
                .filter(this.filterCompiler)
                .map(async (child) => {
                await this.bud.fs.remove(child.path(`@dist`));
                await this.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", child.path(`@dist`)] }) }));
            }));
        }
        await this.bud.fs.remove(this.bud.path(`@dist`));
        await this.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", this.bud.path(`@dist`)] }) }));
    }
    async cleanStorage() {
        if (this.bud.hasChildren) {
            return await Promise.all(Object.values(this.bud.children)
                .filter(this.filterCompiler)
                .map(async (child) => {
                await this.bud.fs.remove(child.path(`@storage`));
                await this.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", child.path(`@storage`)] }) }));
            }));
        }
        await this.bud.fs.remove(this.bud.path(`@storage`));
        await this.bud.fs.remove(this.bud.path(`@os-cache`));
        await this.renderStatic(_jsx(Box, { children: _jsxs(Text, { color: "green", children: ["\u2714 emptied ", this.bud.path(`@storage`)] }) }));
    }
    /**
     * {@link Command.execute}
     */
    async execute() {
        await this.makeBud();
        await this.healthcheck(this);
        const cleanAll = !this.outputPositional &&
            !this.storagePositional &&
            !this.cachePositional;
        if (this.storagePositional || cleanAll) {
            await this.cleanStorage();
        }
        if (this.outputPositional || cleanAll) {
            await this.cleanOutput();
        }
        if (this.cachePositional || cleanAll) {
            await this.cleanCache();
        }
    }
    filterCompiler(child) {
        return !this.filter || this.filter.includes(child.label);
    }
};
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BudCleanCommand.prototype, "cleanCache", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BudCleanCommand.prototype, "cleanOutput", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], BudCleanCommand.prototype, "cleanStorage", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Boolean)
], BudCleanCommand.prototype, "filterCompiler", null);
BudCleanCommand = __decorate([
    dry
], BudCleanCommand);
export default BudCleanCommand;
