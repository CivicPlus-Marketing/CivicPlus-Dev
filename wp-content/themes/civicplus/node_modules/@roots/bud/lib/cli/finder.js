import { __decorate, __metadata } from "tslib";
import { bind } from '@roots/bud-support/decorators/bind';
import { resolve } from '@roots/bud-support/import-meta-resolve';
import isString from '@roots/bud-support/lodash/isString';
import { filesystem } from '@roots/bud-support/utilities/filesystem';
import { dirname, join } from 'node:path/posix';
import { fileURLToPath } from 'node:url';
/**
 * Command finder class
 */
export class Commands {
    context;
    application;
    static instance;
    fs = filesystem;
    paths;
    /**
     */
    constructor(context, application) {
        this.context = context;
        this.application = application;
    }
    /**
     * @public
     * @static
     */
    static get(application, context) {
        if (Commands.instance)
            return Commands.instance;
        else {
            Commands.instance = new Commands(context, application);
            return Commands.instance;
        }
    }
    static async importCommandsFromPaths(paths) {
        try {
            return await Promise.all(paths.map(async (path) => {
                try {
                    return await import(path).then(({ default: register }) => register);
                }
                catch (error) { }
            }));
        }
        catch (error) { }
    }
    /**
     * Find commands shipped with a given extension
     */
    findExtensionCommandPaths(paths) {
        return paths
            .map(dirname)
            .map(path => join(path, join(`bud`, `commands`, `index.js`)));
    }
    /**
     * Get commands
     *
     * @remarks
     * Returns cached commands if they exist, otherwise
     * resolves and caches commands from project dependencies.
     */
    async getCommands() {
        try {
            if (await this.fs.exists(join(this.context.paths.storage, `commands`))) {
                const paths = await this.fs.read(join(this.context.paths.storage, `commands.yml`));
                if (Array.isArray(paths))
                    return paths;
            }
        }
        catch (error) { }
        const resolvedExtensionPaths = await this.getRegistrationModulePaths();
        await this.fs.write(join(this.context.paths.storage, `commands.yml`), resolvedExtensionPaths);
        return resolvedExtensionPaths;
    }
    /**
     * Get array of project dependency and devDependency signifiers
     */
    getProjectDependencySignifiers() {
        return Object.keys({
            ...(this.context.manifest?.dependencies ?? {}),
            ...(this.context.manifest?.devDependencies ?? {}),
        }).filter(signifier => !signifier.startsWith(`@types`));
    }
    /**
     */
    async getRegistrationModulePaths() {
        return await this.resolveExtensionCommandPaths(this.getProjectDependencySignifiers())
            .then(this.findExtensionCommandPaths)
            .then(this.resolveExtensionCommandPaths);
    }
    async resolveExtensionCommandPaths(paths) {
        return await Promise.all(paths.map(async (path) => {
            try {
                return await resolve(path, import.meta.url);
            }
            catch (error) { }
        }))
            .then(paths => paths.filter(isString).map(fileURLToPath))
            .then(async (paths) => await Promise.all(paths.map(async (path) => {
            try {
                const exists = await this.fs.exists(path);
                if (exists)
                    return path;
            }
            catch (error) { }
        })).then(paths => paths.filter(Boolean)));
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", void 0)
], Commands.prototype, "findExtensionCommandPaths", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Commands.prototype, "getCommands", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Array)
], Commands.prototype, "getProjectDependencySignifiers", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Commands.prototype, "getRegistrationModulePaths", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Array]),
    __metadata("design:returntype", Promise)
], Commands.prototype, "resolveExtensionCommandPaths", null);
