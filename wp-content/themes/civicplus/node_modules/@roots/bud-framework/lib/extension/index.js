var _a, _b;
import { __decorate, __metadata } from "tslib";
import { bind } from '@roots/bud-support/decorators/bind';
import { BudError, ImportError } from '@roots/bud-support/errors';
import get from '@roots/bud-support/lodash/get';
import isFunction from '@roots/bud-support/lodash/isFunction';
import isObject from '@roots/bud-support/lodash/isObject';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
import set from '@roots/bud-support/lodash/set';
import logger from '@roots/bud-support/logger';
import DynamicOption from '@roots/bud-support/value';
/**
 * Bud extension
 */
export class Extension {
    /**
     * Application
     */
    _app;
    /**
     * Extension options
     */
    _options;
    /**
     * Depends on
     */
    dependsOn;
    /**
     * Depends on (optional)
     */
    dependsOnOptional;
    /**
     * Is extension enabled
     *
     * @remarks
     * The following methods are skipped if `enabled` is false:
     * - {@link Extension.buildBefore}
     * - {@link Extension.make}
     */
    enabled = true;
    get = this.getOption;
    /**
     * The module name
     */
    label;
    /**
     * Extension meta
     */
    meta = {
        boot: false,
        buildAfter: false,
        buildBefore: false,
        configAfter: false,
        register: false,
    };
    /**
     * Extension options
     *
     * @readonly
     */
    options;
    /**
     * Plugin constructor
     */
    plugin;
    set = this.setOption;
    /**
     * Class constructor
     */
    constructor(app) {
        this._app = () => app;
        this._options = this.options ? { ...this.options } : {};
        delete this.options;
        Object.defineProperty(this, `options`, {
            get: this.getOptions.bind(this),
        });
    }
    /**
     * `boot` callback handler
     */
    async _boot() {
        if (this.meta[`boot`] === true)
            return;
        this.meta[`boot`] = true;
        try {
            await this.boot(this.app);
        }
        catch (error) {
            throw error;
        }
        this.logger.success(`booted`);
    }
    /**
     * `buildAfter` callback handler
     */
    async _buildAfter() {
        if (isUndefined(this.buildAfter))
            return;
        if (!this.isEnabled())
            return;
        if (this.meta[`buildAfter`] === true)
            return;
        this.meta[`buildAfter`] = true;
        try {
            await this.buildAfter(this.app);
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * `buildBefore` callback handler
     */
    async _buildBefore() {
        if (isUndefined(this.buildBefore))
            return;
        if (!this.isEnabled())
            return;
        if (this.meta[`buildBefore`] === true)
            return;
        this.meta[`buildBefore`] = true;
        try {
            await this.buildBefore(this.app);
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * `configAfter` callback handler
     */
    async _configAfter() {
        if (isUndefined(this.configAfter))
            return;
        if (!this.isEnabled())
            return;
        if (this.meta[`configAfter`] === true)
            return;
        this.meta[`configAfter`] = true;
        try {
            await this.configAfter(this.app);
        }
        catch (error) {
            throw error;
        }
    }
    /**
     * `make` callback handler
     */
    async _make() {
        if (isUndefined(this.make) && isUndefined(this.plugin)) {
            return false;
        }
        if (this.isEnabled() === false) {
            return false;
        }
        try {
            if (!isUndefined(this.apply)) {
                this.logger.info(`apply prop found. return extension instance`);
                return this;
            }
            if (!isUndefined(this.plugin)) {
                const plugin = new this.plugin({ ...this.options });
                this.logger.success(`produced webpack plugin`);
                return plugin;
            }
            if (!isUndefined(this.make)) {
                const plugin = await this.make(this.app, { ...this.options });
                this.logger.success(`produced webpack plugin`);
                return plugin;
            }
        }
        catch (error) {
            const ident = this.label ?? this.constructor?.name ?? `unknown_extension`;
            throw new BudError(`Error instantiating ${ident}`, {
                props: {
                    details: `Check options for ${ident}`,
                    docs: new URL(`https://bud.js.org/docs/extensions`),
                    issues: new URL(`https://github.com/roots/bud/search?q=is:issue+${ident} in:title`),
                    origin: BudError.normalize(error),
                    thrownBy: this.constructor.name,
                },
            });
        }
    }
    /**
     * `register` callback handler
     */
    async _register() {
        if (this.meta[`register`] === true)
            return;
        this.meta[`register`] = true;
        try {
            await this.register(this.app);
        }
        catch (error) {
            throw error;
        }
        this.logger.success(`registered`);
    }
    /**
     * Application accessor
     */
    get app() {
        return this._app();
    }
    /**
     * `boot` callback
     *
     * @param options - Extension options
     * @param app - Bud instance
     */
    async boot(app) { }
    /**
     * `configAfter` callback
     */
    async configAfter(app) { }
    /**
     * Disable extension
     * @deprecated pass `false` to {@link Extension.enable}
     */
    disable() {
        this.enabled = false;
    }
    /**
     * Return to bud instance from extension
     */
    done() {
        return this.app;
    }
    /**
     * Enable extension
     */
    enable(enabled = true) {
        this.enabled = enabled;
        return this;
    }
    /**
     * Get extension option
     */
    getOption(key) {
        return get(this.options, key);
    }
    getOptions() {
        return Object.entries(this._options).reduce((acc, [key, value]) => {
            if (isUndefined(value))
                return acc;
            if (!isObject(value))
                return { ...acc, [key]: value };
            const isDynamicOption = (value) => {
                return (value instanceof DynamicOption ||
                    (`isBudValue` in value && value.isBudValue));
            };
            const unwrapped = isDynamicOption(value)
                ? value.get()(this.app)
                : value;
            if (isUndefined(unwrapped))
                return acc;
            return { ...acc, [key]: unwrapped };
        }, {});
    }
    /**
     * Import ESM module
     */
    async import(signifier, context) {
        try {
            return await this.app.module.import(signifier, context);
        }
        catch (error) {
            throw new ImportError(`could not import ${signifier}`, {
                props: {
                    origin: ImportError.normalize(error),
                    thrownBy: this.label,
                },
            });
        }
    }
    /**
     * Is extension enabled?
     */
    isEnabled() {
        return this.when(this.app, this.options);
    }
    /**
     * Logger instance
     */
    get logger() {
        return logger.scope(...[this.app.label, this.label].filter(Boolean));
    }
    /**
     * {@link Extension.register}
     */
    async register(app) { }
    /**
     * Resolve module using `import.meta.resolve` api
     */
    async resolve(signifier, context) {
        try {
            return await this.app.module.resolve(signifier, context);
        }
        catch (error) {
            const cause = BudError.normalize(error);
            throw new ImportError(`could not resolve ${signifier}`, {
                props: {
                    origin: cause,
                    thrownBy: this.label,
                },
            });
        }
    }
    /**
     * Set extension option
     */
    setOption(key, valueOrCallback) {
        if (isFunction(valueOrCallback)) {
            set(this._options, key, valueOrCallback(this.get(key)));
            return this;
        }
        set(this._options, key, valueOrCallback);
        return this;
    }
    /**
     * Set extension options
     */
    setOptions(value) {
        this._options = value;
        return this;
    }
    /**
     * Function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * By default returns {@link Extension.enabled}
     */
    when(bud, options) {
        return this.enabled;
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_boot", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_buildAfter", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_buildBefore", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_configAfter", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_make", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Extension.prototype, "_register", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], Extension.prototype, "disable", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Function)
], Extension.prototype, "done", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Boolean]),
    __metadata("design:returntype", void 0)
], Extension.prototype, "enable", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof K !== "undefined" && K) === "function" ? _a : Object]),
    __metadata("design:returntype", Object)
], Extension.prototype, "getOption", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Extension.prototype, "import", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Boolean)
], Extension.prototype, "isEnabled", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Promise)
], Extension.prototype, "resolve", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof K !== "undefined" && K) === "function" ? _b : Object, Object]),
    __metadata("design:returntype", Object)
], Extension.prototype, "setOption", null);
export { DynamicOption };
