var _a, _b, _c, _d;
import { __decorate, __metadata } from "tslib";
import { Service } from '@roots/bud-framework/service';
import { bind } from '@roots/bud-support/decorators/bind';
import isFunction from '@roots/bud-support/lodash/isFunction';
import isUndefined from '@roots/bud-support/lodash/isUndefined';
import { register } from './handlers/register.js';
import { Item } from './item/index.js';
import { Loader } from './loader/index.js';
import { Rule } from './rule/index.js';
/**
 * Webpack configuration builder class
 */
export class Build extends Service {
    /**
     * Built config object
     */
    config = {};
    /**
     * Registered items
     */
    items = {};
    /**
     * Registered loaders
     */
    loaders = {};
    /**
     * Service register event
     *
     * @remarks
     * `loaders`, `items`, and `rules` are instantiated dumbly
     * because it is painful to think about how to map the typings..
     */
    register = register.bind(this);
    /**
     * Registered rules
     */
    rules = {};
    /**
     * Get item
     */
    getItem(name) {
        if (!this.items[name])
            this.logger.error(`loader ${name} was requested but is not registered`);
        return this.items[name];
    }
    /**
     * Get loader
     */
    getLoader(name) {
        if (!this.loaders[name])
            this.logger.error(`loader ${name} was requested but is not registered`);
        return this.loaders[name];
    }
    /**
     * Get rule
     */
    getRule(ident) {
        return this.rules[ident];
    }
    /**
     * Make webpack configuration
     */
    async make() {
        this.logger.log(`bud.build.make called`);
        await this.app.hooks.fire(`build.before`, this.app);
        await import(`./config/index.js`).then(async (records) => await Promise.all(Object.entries(records).map(async ([prop, factory]) => {
            try {
                const value = await factory(this.app);
                if (isUndefined(value))
                    return;
                this.config[prop] = value;
                this.logger.success(`built`, prop);
            }
            catch (error) {
                throw error;
            }
        })));
        this.logger.success(`configuration successfully built`);
        await this.app.hooks.fire(`build.after`, this.app);
        return this.config;
    }
    /**
     * Make item
     */
    makeItem(options) {
        return new Item(() => this.app, options);
    }
    /**
     * Make loader
     */
    makeLoader(src, definition) {
        return new Loader(() => this.app, src, definition);
    }
    /**
     * Make Rule
     */
    makeRule(options) {
        return new Rule(() => this.app, options);
    }
    /**
     * Set item
     */
    setItem(ident, options) {
        const maybeOptionsCallback = isUndefined(options)
            ? { ident, loader: ident }
            : options;
        const item = isFunction(maybeOptionsCallback)
            ? maybeOptionsCallback(this.makeItem())
            : this.makeItem(maybeOptionsCallback);
        this.items[ident] = item;
        this.logger.info(`set item`, item);
        return this;
    }
    /**
     * Set loader
     */
    setLoader(name, definition) {
        const loader = isUndefined(definition)
            ? this.makeLoader(name)
            : definition instanceof Loader
                ? definition
                : this.makeLoader(definition);
        this.loaders[name] = loader;
        this.logger.info(`set loader`, loader);
        return this;
    }
    /**
     * Set Rule
     */
    setRule(name, input) {
        this.rules[name] =
            input instanceof Rule
                ? input
                : isFunction(input)
                    ? input(this.makeRule())
                    : this.makeRule(input);
        return this;
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Item)
], Build.prototype, "getItem", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Loader)
], Build.prototype, "getLoader", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_a = typeof K !== "undefined" && K) === "function" ? _a : Object]),
    __metadata("design:returntype", Object)
], Build.prototype, "getRule", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Build.prototype, "make", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Item)
], Build.prototype, "makeItem", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String, String]),
    __metadata("design:returntype", Loader)
], Build.prototype, "makeLoader", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Rule)
], Build.prototype, "makeRule", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_b = typeof K !== "undefined" && K) === "function" ? _b : Object, Object]),
    __metadata("design:returntype", Object)
], Build.prototype, "setItem", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_c = typeof K !== "undefined" && K) === "function" ? _c : Object, Object]),
    __metadata("design:returntype", Object)
], Build.prototype, "setLoader", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [typeof (_d = typeof K !== "undefined" && K) === "function" ? _d : Object, Object]),
    __metadata("design:returntype", Object)
], Build.prototype, "setRule", null);
