import { __decorate, __metadata } from "tslib";
import { Service } from '@roots/bud-framework/service';
import { bind } from '@roots/bud-support/decorators/bind';
import isString from '@roots/bud-support/lodash/isString';
import { hash } from '@roots/bud-support/utilities/args';
import { createHash } from 'node:crypto';
import { join } from 'node:path';
import InvalidateCacheExtension from '../invalidate-cache/index.js';
/**
 * Cache service class
 */
export default class Cache extends Service {
    /**
     * Enabled
     */
    enabled = true;
    /**
     * {@link Extension.boot}
     */
    async boot(bud) {
        await bud.extensions.add(InvalidateCacheExtension);
        this.logger.success(`cache initialized`);
    }
    /**
     * Cache dependencies
     */
    get buildDependencies() {
        return this.app.hooks.filter(`build.cache.buildDependencies`, {
            bud: [
                this.app.context.files?.[`package.json`]?.path,
                ...Object.values(this.app.context.files)
                    .filter(({ bud }) => bud)
                    .map(({ path }) => path),
            ].filter(Boolean),
        });
    }
    set buildDependencies(dependencies) {
        this.app.hooks.on(`build.cache.buildDependencies`, dependencies);
    }
    /**
     * Cache directory
     */
    get cacheDirectory() {
        return this.app.hooks.filter(`build.cache.cacheDirectory`, this.app.path(`@storage`, this.app.label, `cache`));
    }
    set cacheDirectory(directory) {
        this.app.hooks.on(`build.cache.cacheDirectory`, directory);
    }
    /**
     * Webpack configuration
     */
    get configuration() {
        if (this.enabled !== true)
            return false;
        if (this.type === `memory`)
            return true;
        return {
            allowCollectingMemory: true,
            buildDependencies: this.buildDependencies,
            cacheDirectory: this.cacheDirectory,
            idleTimeout: 10000,
            idleTimeoutForInitialStore: 0,
            name: this.name,
            profile: this.app.context.debug === true,
            store: `pack`,
            type: this.type,
            version: this.app.hooks.filter(`build.cache.version`, this.version),
        };
    }
    /**
     * Flush cache
     */
    async flush() {
        await this.app.fs.remove(this.cacheDirectory);
    }
    /**
     * Type
     */
    get name() {
        return this.app.hooks.filter(`build.cache.name`, this.app.hooks.filter(`build.name`, join(`webpack`, this.app.mode)));
    }
    set name(name) {
        this.app.hooks.on(`build.cache.name`, name);
    }
    /**
     * Type
     */
    get type() {
        return this.app.hooks.filter(`build.cache.type`, isString(this.app.context.cache)
            ? this.app.context.cache
            : `filesystem`);
    }
    set type(type) {
        this.app.hooks.on(`build.cache.type`, type);
    }
    /**
     * version
     */
    get version() {
        const version = createHash(`sha1`);
        version.update(hash);
        Object.values(this.app.context.files ?? {})
            .filter(file => file?.bud || file?.name?.includes(`package.json`))
            .map(({ sha1 }) => version.update(sha1));
        return this.app.hooks.filter(`build.cache.version`, version.digest(`base64`));
    }
    set version(version) {
        this.app.hooks.on(`build.cache.version`, version);
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", Promise)
], Cache.prototype, "boot", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Promise)
], Cache.prototype, "flush", null);
