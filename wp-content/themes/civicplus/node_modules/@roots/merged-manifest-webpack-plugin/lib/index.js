// Copyright Â© Roots Software Foundation LLC
// Licensed under the MIT license.
import { __decorate, __metadata } from "tslib";
import fs from 'fs-jetpack';
import { bind } from 'helpful-decorators';
import path from 'node:path';
/**
 * Merged Manifest Webpack Plugin
 */
export default class MergedManifestWebpackPlugin {
    /**
     * Directory where the manifest will be written.
     */
    dir;
    /**
     * Entrypoints manifest
     */
    entrypointsName = `entrypoints.json`;
    /**
     * Output file
     */
    file = `entrypoints.json`;
    /**
     * Plugin ident
     */
    plugin = {
        name: `MergedManifestPlugin`,
    };
    /**
     * WordPress manifest
     */
    wordpressName = `wordpress.json`;
    /**
     * Plugin constructor
     */
    constructor(options) {
        options &&
            Object.keys(options).map(prop => {
                Object.assign(this, { [prop]: options[prop] });
            });
    }
    /**
     */
    apply(compiler) {
        this.dir = compiler.options.output.path;
        compiler.hooks.done.tapAsync(this.plugin, this.done);
    }
    /**
     */
    async done(_stats, callback) {
        // Missing manifests
        if (!this.isBuildable())
            return callback();
        /**
         * Read manifests.
         */
        try {
            const entrypointsManifest = await this.manifestContent(this.entrypointsName);
            const wordpressManifest = await this.manifestContent(this.wordpressName);
            /**
             * Reduce aggregate manifest and write to file.
             */
            await fs.writeAsync(this.manifestPath(this.file), this.format(Object.entries(entrypointsManifest).reduce((acc, [key, value]) => {
                return {
                    ...acc,
                    [key]: {
                        ...value,
                        ...{ dependencies: wordpressManifest[key] },
                    },
                };
            }, {})));
            /**
             * Remove wordpress.json manifest.
             */
            await fs.removeAsync(this.manifestPath(this.wordpressName));
        }
        catch (err) {
            throw new Error(err);
        }
        return callback();
    }
    /**
     */
    format(object) {
        return JSON.stringify(object, null, 2);
    }
    /**
     */
    isBuildable() {
        return (this.manifestExists(this.entrypointsName) &&
            this.manifestExists(this.wordpressName));
    }
    /**
     */
    async manifestContent(file) {
        return await fs.readAsync(this.manifestPath(file), `json`);
    }
    /**
     */
    manifestExists(file) {
        return !!fs.exists(this.manifestPath(file));
    }
    /**
     */
    manifestPath(file) {
        return path.resolve(this.dir, file);
    }
}
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function]),
    __metadata("design:returntype", void 0)
], MergedManifestWebpackPlugin.prototype, "apply", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Function, Object]),
    __metadata("design:returntype", Promise)
], MergedManifestWebpackPlugin.prototype, "done", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", String)
], MergedManifestWebpackPlugin.prototype, "format", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", Boolean)
], MergedManifestWebpackPlugin.prototype, "isBuildable", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Promise)
], MergedManifestWebpackPlugin.prototype, "manifestContent", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", Boolean)
], MergedManifestWebpackPlugin.prototype, "manifestExists", null);
__decorate([
    bind,
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [String]),
    __metadata("design:returntype", String)
], MergedManifestWebpackPlugin.prototype, "manifestPath", null);
