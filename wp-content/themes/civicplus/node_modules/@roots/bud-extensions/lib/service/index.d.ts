import type { Bud, Modules } from '@roots/bud-framework';
import type { ApplyPlugin } from '@roots/bud-framework/extension';
import type { Extensions as Contract } from '@roots/bud-framework/services';
import { Extension } from '@roots/bud-framework/extension';
import { Service } from '@roots/bud-framework/service';
import Container from '@roots/container';
/**
 * Extensions Service
 */
export default class Extensions extends Service implements Contract.Service {
    /**
     * Registered extensions
     */
    /**
     * Resolved options
     */
    options: Container<{
        allowlist: Array<string>;
        denylist: Array<string>;
        discover: boolean;
    }>;
    repository: Modules;
    /**
  -   * Modules on which an import attempt was made and failed
  -   *
  -   * @remarks
  -   * This doesn't mean an error, per se. This should only
  -   * be used in the context of trying to import `optionalDependencies`
  -   * of a given extension module.
  -   *
  -   * @public
  -   */
    unresolvable: Set<string>;
    constructor(bud: () => Bud);
    /**
     * Add a {@link Extension} to the extensions repository
     */
    add<K extends `${keyof Modules & string}`>(extension: Array<K | (new (bud: Bud) => Partial<Extension>) | Partial<Extension>> | K | (new (bud: Bud) => Partial<Extension>) | Partial<Extension>): Promise<void>;
    /**
     * `booted` callback
     */
    boot(bud: Bud): Promise<void>;
    /**
     * {@link Extension.buildBefore}
     */
    buildAfter?(): Promise<void>;
    /**
     * {@link Extension.buildBefore}
     */
    buildBefore?(): Promise<void>;
    /**
     * `configAfter` callback
     */
    configAfter?(): Promise<void>;
    /**
     * Get extension
     */
    get<K extends `${keyof Modules & string}`>(key: K): Modules[K];
    /**
     * Has extension
     */
    has(key: string): key is keyof Modules;
    /**
     * Import an extension
     */
    import(signifier: string, required: boolean | number, context: string): Promise<Extension>;
    /**
     * Instantiate a Framework extension class or object
     */
    instantiate(source: {
        apply: (...args: any[]) => any;
    } | Extension | (new (...args: any[]) => Extension)): Promise<Extension>;
    isAllowed(signifier: string): boolean;
    /**
     * Returns an array of plugin instances which have been registered to the
     * container and are set to be used in the compilation
     *
     * @returns An array of plugin instances
     */
    make(): Promise<ApplyPlugin[]>;
    /**
     * `register` callback
     *
     * @todo
     * All this is doing is helping transition people to using `bud.extensions` key for
     * `allowList` and `denyList`. It can be removed in a future release. (2022-10-18)
     */
    register(bud: Bud): Promise<void>;
    /**
     * Remove extension
     */
    remove<K extends `${keyof Modules & string}`>(key: K): this;
    /**
     * Run an extension lifecycle method
     *
     * @remarks
     * - `_register`
     * - `_boot`
     * - `_buildBefore`
     * - `_make`
     */
    run(extension: Extension, methodName: Contract.LifecycleMethods): Promise<this>;
    /**
     * Execute a extension lifecycle method on all registered extensions
     */
    runAll(methodName: Contract.LifecycleMethods): Promise<any>;
    /**
     * Run a lifecycle method for an extension's dependencies
     *
     * @remarks
     * Called from {@link Extension.run}. Ensures a method is run for an
     * extension's dependencies before it is run for the extension itself.
     */
    runDependencies<K extends `${keyof Modules & string}`>(extension: Extension | K, methodName: Contract.LifecycleMethods): Promise<void>;
    /**
     * Set extension
     */
    set(value: Extension): this;
}
